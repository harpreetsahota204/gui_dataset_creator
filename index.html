<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUI Dataset Collector - Server Edition</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            border-right: 1px solid #e0e0e0;
        }

        .side-panel {
            width: 450px;
            background: white;
            padding: 20px;
            overflow-y: auto;
        }

        .toolbar {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .button:hover {
            background: #f0f0f0;
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .button.primary:hover {
            background: #0056b3;
        }

        .button.danger {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        .button.danger:hover {
            background: #c82333;
        }

        .button.success {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .button.success:hover {
            background: #218838;
        }

        .button.warning {
            background: #ffc107;
            color: #000;
            border-color: #ffc107;
        }

        .button.warning:hover {
            background: #e0a800;
        }

        .button.active {
            background: #ffc107;
            color: #000;
            border-color: #ffc107;
        }

        .preview-area {
            flex: 1;
            position: relative;
            overflow: auto;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .screenshot-container {
            position: relative;
            display: inline-block;
        }

        .screenshot {
            max-width: 100%;
            height: auto;
            display: block;
            cursor: crosshair;
        }

        .bbox-overlay {
            position: absolute;
            border: 2px solid #ff0000;
            background: rgba(255, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .bbox-overlay:hover {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff3333;
        }

        .bbox-overlay.selected {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.2);
            border-width: 3px;
        }

        .bbox-overlay.selected:hover {
            background: rgba(255, 193, 7, 0.3);
        }

        .bbox-label {
            position: absolute;
            top: -24px;
            left: 0;
            background: #ff0000;
            color: white;
            padding: 2px 6px;
            font-size: 12px;
            border-radius: 3px;
            pointer-events: none;
            user-select: none;
        }

        .bbox-overlay.selected .bbox-label {
            background: #ffc107;
            color: #000;
        }

        .annotation-marker {
            position: absolute;
            min-width: 24px;
            height: 24px;
            padding: 0 6px;
            border: 2px solid #0066ff;
            border-radius: 12px;
            background: rgba(0, 102, 255, 0.8);
            color: white;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: all 0.2s;
            pointer-events: auto;
        }

        .annotation-marker:hover {
            background: rgba(0, 102, 255, 1);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .annotation-marker.selected {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.8);
            border-width: 3px;
        }

        .annotation-marker.selected:hover {
            background: rgba(255, 193, 7, 1);
        }

        .video-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }

        .video-stream {
            max-width: 100%;
            height: auto;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
        }

        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-control:focus {
            outline: none;
            border-color: #007bff;
        }

        .annotation-list {
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .annotation-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
            padding-right: 40px;
        }

        .annotation-item:hover {
            background: #f8f9fa;
        }

        .annotation-item.selected {
            background: #e3f2fd;
        }

        .annotation-item:last-child {
            border-bottom: none;
        }

        .annotation-type-badge {
            display: inline-block;
            padding: 2px 6px;
            background: #e0e0e0;
            border-radius: 3px;
            font-size: 11px;
            margin-left: 5px;
        }

        .annotation-type-badge.bbox {
            background: #ffebee;
            color: #c62828;
        }

        .annotation-type-badge.point {
            background: #e3f2fd;
            color: #1565c0;
        }

        .delete-annotation {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            border: none;
            background: #dc3545;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
            padding: 0;
            transition: background 0.2s;
        }

        .delete-annotation:hover {
            background: #c82333;
        }

        .status-bar {
            padding: 10px 15px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            font-size: 14px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mode-indicator {
            display: inline-block;
            padding: 4px 8px;
            background: #e0e0e0;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .mode-indicator.drawing {
            background: #ffc107;
            color: #000;
        }

        .mode-indicator.streaming {
            background: #28a745;
            color: white;
        }

        .instructions {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #0c5460;
        }

        .file-status {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 13px;
            color: #155724;
        }

        .file-status.error {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .dataset-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .button-group .button {
            flex: 1;
        }

        .keyboard-hint {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .annotation-info {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .annotation-info strong {
            color: #333;
        }

        .metadata-container {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .metadata-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .metadata-item input {
            flex: 1;
        }

        .metadata-item .button {
            padding: 4px 8px;
            font-size: 12px;
        }

        .add-metadata {
            width: 100%;
            padding: 8px;
            border: 1px dashed #ddd;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            color: #666;
        }

        .add-metadata:hover {
            background: #f8f9fa;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .side-panel {
                width: 100%;
                height: 50vh;
                border-top: 1px solid #e0e0e0;
            }
        }

        .sequence-indicator {
            display: inline-block;
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            margin-left: 10px;
        }

        .sequence-history {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .history-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-item-number {
            background: #007bff;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .history-item-action {
            flex: 1;
        }

        .history-item-time {
            color: #666;
            font-size: 11px;
        }

        .sequence-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #0c5460;
        }

        .sequence-metadata {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }

        .autocomplete-container {
            position: relative;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background: #f0f0f0;
        }

        .autocomplete-suggestion.selected {
            background: #007bff;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-panel">
            <div class="toolbar">
                <button class="button primary" id="startStreamBtn">Start Live Capture</button>
                <button class="button" id="captureFrameBtn" disabled>Capture Frame</button>
                <button class="button warning" id="refreshStreamBtn" disabled title="Refresh stream (Ctrl+R / Cmd+R)">↻ Refresh Stream</button>
                <button class="button" id="drawBboxBtn" disabled>Draw Bounding Box</button>
                <button class="button" id="addPointBtn" disabled>Add Click Point</button>
                <button class="button danger" id="stopStreamBtn" disabled>Stop Stream</button>
                <button class="button success" id="loadDatasetBtn">Load Existing Dataset</button>
                <div style="flex: 1;"></div>
                <button class="button success" id="startSequenceBtn">Start Sequence</button>
                <button class="button danger" id="endSequenceBtn" disabled>End Sequence</button>
                <span id="sequenceIndicator" class="sequence-indicator" style="display: none;">
                    Sequence: <span id="sequenceId"></span> (Frame <span id="sequenceFrameCount">0</span>)
                </span>
            </div>
            
            <div class="preview-area" id="previewArea">
                <div id="videoContainer" class="video-container" style="display: none;">
                    <video id="videoStream" class="video-stream" autoplay></video>
                </div>
                <div id="screenshotContainer" class="screenshot-container" style="display: none;">
                    <img id="screenshot" class="screenshot" alt="Screenshot">
                </div>
                <div id="placeholder" style="color: #666; text-align: center;">
                    <p>No capture active</p>
                    <p style="margin-top: 10px; font-size: 14px;">Click "Start Live Capture" to begin</p>
                </div>
            </div>
            
            <div class="status-bar">
                <span id="statusText">Ready</span>
                <span id="modeIndicator" class="mode-indicator">Idle</span>
            </div>
        </div>
        
        <div class="side-panel">
            <div class="section">
                <h3 class="section-title">Dataset Statistics</h3>
                <div class="dataset-stats">
                    <div class="stat-card">
                        <div class="stat-number" id="imageCount">0</div>
                        <div class="stat-label">Images</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="annotationCount">0</div>
                        <div class="stat-label">Annotations</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3 class="section-title">Capture Instructions</h3>
                <div class="instructions">
                    <strong>Live Capture Mode:</strong><br>
                    1. Click "Start Live Capture" and select window<br>
                    2. Interact with the window normally<br>
                    3. Click "Capture Frame" when ready<br>
                    4. <strong>Click on bounding boxes/points to edit them</strong><br>
                    5. Add task descriptions and metadata per annotation<br>
                    6. Save frame to <code>data/</code> folder<br><br>
                    <strong>New Features:</strong><br>
                    • <strong>Refresh Stream:</strong> Update screen capture without restarting<br>
                    • Annotations are clickable and editable<br>
                    • Task descriptions at annotation level<br>
                    • Image metadata (app/platform)<br>
                    • Custom annotation metadata support
                </div>
            </div>

            <div class="section" id="sequenceSection" style="display: none;">
                <h3 class="section-title">Sequence Information</h3>
                <div class="sequence-info" id="sequenceInfo">
                    <strong>Sequence ID:</strong> <span id="currentSequenceId"></span><br>
                    <strong>Frames in Sequence:</strong> <span id="currentSequenceFrames">0</span><br>
                    <strong>Started:</strong> <span id="sequenceStartTime"></span>
                </div>
                
                <h4 class="section-title">Action History</h4>
                <div class="sequence-history" id="sequenceHistory">
                    <div style="padding: 10px; color: #666; text-align: center;">No actions in sequence yet</div>
                </div>
            </div>

            <div class="section">
                <h3 class="section-title">Current Frame Info</h3>
                <div class="form-group">
                    <label>Frame ID</label>
                    <input type="text" class="form-control" id="frameId" readonly>
                </div>
                <div class="form-group">
                    <label>Application</label>
                    <input type="text" class="form-control" id="application" placeholder="e.g., Chrome, Photoshop, VSCode">
                </div>
                <div class="form-group">
                    <label>Platform</label>
                    <select class="form-control" id="platform">
                        <option value="">Select platform</option>
                        <option value="Windows">Windows</option>
                        <option value="macOS">macOS</option>
                        <option value="Linux">Linux</option>
                        <option value="Web">Web Browser</option>
                        <option value="Mobile">Mobile</option>
                    </select>
                </div>
                <div class="sequence-metadata" id="frameSequenceMetadata" style="display: none;">
                    <div class="form-group">
                        <label>Sequence Position</label>
                        <input type="text" class="form-control" id="sequencePosition" readonly>
                    </div>
                    <div class="form-group">
                        <label>Previous Action</label>
                        <input type="text" class="form-control" id="previousAction" readonly>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3 class="section-title">Annotations</h3>
                <div class="annotation-list" id="annotationList">
                    <div style="padding: 10px; color: #666; text-align: center;">No annotations yet</div>
                </div>
            </div>
            
            <div class="section" id="annotationForm" style="display: none;">
                <h3 class="section-title">Edit Annotation</h3>
                <div class="annotation-info" id="annotationInfo"></div>
                
                <div class="form-group">
                    <label>Task Description</label>
                    <div class="autocomplete-container">
                        <textarea class="form-control" id="taskDescription" placeholder="Describe what this annotation represents..." rows="2"></textarea>
                        <div class="autocomplete-suggestions" id="taskDescriptionSuggestions"></div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Action Type</label>
                    <select class="form-control" id="actionType">
                        <option value="click">Click</option>
                        <option value="type">Type Text</option>
                        <option value="select">Select</option>
                        <option value="hover">Hover</option>
                        <option value="drag">Drag</option>
                        <option value="right_click">Right Click</option>
                        <option value="double_click">Double Click</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Element Type</label>
                    <select class="form-control" id="elementInfo">
                        <option value="">Select element type</option>
                        <option value="Icon">Icon</option>
                        <option value="Menu Item">Menu Item</option>
                        <option value="Radio Button">Radio Button</option>
                        <option value="Text Input">Text Input</option>
                        <option value="Slider">Slider</option>
                        <option value="Checkbox">Checkbox</option>
                        <option value="Button">Button</option>
                        <option value="Text">Text</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Custom Metadata</label>
                    <div class="metadata-container" id="customMetadata">
                        <button type="button" class="add-metadata" id="addMetadataBtn">+ Add Custom Field</button>
                    </div>
                </div>
                
                <div class="button-group">
                    <button class="button primary" id="saveAnnotationBtn">Save</button>
                    <button class="button danger" id="deleteAnnotationBtn">Delete</button>
                </div>
                <div class="keyboard-hint">Tip: Press Delete key to quickly remove selected annotation</div>
            </div>
            
            <div class="section">
                <button class="button primary" id="saveFrameBtn" style="width: 100%; margin-bottom: 10px;">Save Current Frame</button>
                <button class="button success" id="exportDatasetBtn" style="width: 100%;">Export Full Dataset</button>
                <div id="fileStatus" class="file-status" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        class GUICollectorWithServer {
            constructor() {
                this.serverUrl = 'http://localhost:3000';
                this.stream = null;
                this.currentFrame = null;
                this.frames = [];
                this.mode = 'idle';
                this.drawingBbox = false;
                this.currentBbox = null;
                this.selectedAnnotation = null;
                this.nextFrameId = 1;
                this.nextAnnotationId = 1;
                
                // Sequence tracking
                this.currentSequence = null;
                this.sequenceHistory = [];
                this.sequences = {};
                this.nextSequenceId = 1;
                
                // Autocomplete data
                this.taskDescriptions = new Set();
                this.autocompleteSelectedIndex = -1;
                this.autocompleteVisible = false;
                
                // COCO dataset structure
                this.dataset = {
                    info: {
                        description: "GUI Interaction Dataset",
                        version: "1.0",
                        year: new Date().getFullYear(),
                        contributor: "GUI Dataset Collector",
                        date_created: new Date().toISOString()
                    },
                    licenses: [{
                        id: 1,
                        name: "Attribution License",
                        url: ""
                    }],
                    categories: [
                        { id: 1, name: "click", supercategory: "interaction" },
                        { id: 2, name: "type", supercategory: "interaction" },
                        { id: 3, name: "select", supercategory: "interaction" },
                        { id: 4, name: "hover", supercategory: "interaction" },
                        { id: 5, name: "drag", supercategory: "interaction" },
                        { id: 6, name: "right_click", supercategory: "interaction" },
                        { id: 7, name: "double_click", supercategory: "interaction" }
                    ],
                    images: [],
                    annotations: []
                };
                
                this.initializeElements();
                this.attachEventListeners();
                this.checkServerConnection();
                this.loadExistingDataset();
            }
            
            initializeElements() {
                this.elements = {
                    startStreamBtn: document.getElementById('startStreamBtn'),
                    captureFrameBtn: document.getElementById('captureFrameBtn'),
                    refreshStreamBtn: document.getElementById('refreshStreamBtn'),
                    drawBboxBtn: document.getElementById('drawBboxBtn'),
                    addPointBtn: document.getElementById('addPointBtn'),
                    stopStreamBtn: document.getElementById('stopStreamBtn'),
                    loadDatasetBtn: document.getElementById('loadDatasetBtn'),
                    exportDatasetBtn: document.getElementById('exportDatasetBtn'),
                    videoContainer: document.getElementById('videoContainer'),
                    videoStream: document.getElementById('videoStream'),
                    screenshotContainer: document.getElementById('screenshotContainer'),
                    screenshot: document.getElementById('screenshot'),
                    placeholder: document.getElementById('placeholder'),
                    statusText: document.getElementById('statusText'),
                    modeIndicator: document.getElementById('modeIndicator'),
                    frameId: document.getElementById('frameId'),
                    application: document.getElementById('application'),
                    platform: document.getElementById('platform'),
                    taskDescription: document.getElementById('taskDescription'),
                    annotationList: document.getElementById('annotationList'),
                    annotationForm: document.getElementById('annotationForm'),
                    annotationInfo: document.getElementById('annotationInfo'),
                    actionType: document.getElementById('actionType'),
                    elementInfo: document.getElementById('elementInfo'),
                    customMetadata: document.getElementById('customMetadata'),
                    addMetadataBtn: document.getElementById('addMetadataBtn'),
                    saveAnnotationBtn: document.getElementById('saveAnnotationBtn'),
                    deleteAnnotationBtn: document.getElementById('deleteAnnotationBtn'),
                    saveFrameBtn: document.getElementById('saveFrameBtn'),
                    fileStatus: document.getElementById('fileStatus'),
                    imageCount: document.getElementById('imageCount'),
                    annotationCount: document.getElementById('annotationCount'),
                    taskDescriptionSuggestions: document.getElementById('taskDescriptionSuggestions'),
                    // Sequence elements
                    startSequenceBtn: document.getElementById('startSequenceBtn'),
                    endSequenceBtn: document.getElementById('endSequenceBtn'),
                    sequenceIndicator: document.getElementById('sequenceIndicator'),
                    sequenceId: document.getElementById('sequenceId'),
                    sequenceFrameCount: document.getElementById('sequenceFrameCount'),
                    sequenceSection: document.getElementById('sequenceSection'),
                    sequenceInfo: document.getElementById('sequenceInfo'),
                    currentSequenceId: document.getElementById('currentSequenceId'),
                    currentSequenceFrames: document.getElementById('currentSequenceFrames'),
                    sequenceStartTime: document.getElementById('sequenceStartTime'),
                    sequenceHistory: document.getElementById('sequenceHistory'),
                    frameSequenceMetadata: document.getElementById('frameSequenceMetadata'),
                    sequencePosition: document.getElementById('sequencePosition'),
                    previousAction: document.getElementById('previousAction')
                };
            }
            
            attachEventListeners() {
                this.elements.startStreamBtn.addEventListener('click', () => this.startStream());
                this.elements.captureFrameBtn.addEventListener('click', () => this.captureFrame());
                this.elements.refreshStreamBtn.addEventListener('click', () => this.refreshStream());
                this.elements.drawBboxBtn.addEventListener('click', () => this.toggleDrawMode());
                this.elements.addPointBtn.addEventListener('click', () => this.togglePointMode());
                this.elements.stopStreamBtn.addEventListener('click', () => this.stopStream());
                this.elements.loadDatasetBtn.addEventListener('click', () => this.loadExistingDataset());
                this.elements.exportDatasetBtn.addEventListener('click', () => this.exportDataset());
                this.elements.saveAnnotationBtn.addEventListener('click', () => this.saveAnnotation());
                this.elements.deleteAnnotationBtn.addEventListener('click', () => this.deleteSelectedAnnotation());
                this.elements.saveFrameBtn.addEventListener('click', () => this.saveCurrentFrame());
                this.elements.addMetadataBtn.addEventListener('click', () => this.addMetadataField());
                
                // Sequence events
                this.elements.startSequenceBtn.addEventListener('click', () => this.startSequence());
                this.elements.endSequenceBtn.addEventListener('click', () => this.endSequence());
                
                // Autocomplete events
                this.setupAutocomplete();
                
                // Mouse events for drawing
                this.elements.screenshot.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.elements.screenshot.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.elements.screenshot.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Prevent screenshot clicks from bubbling when not in drawing mode
                this.elements.screenshot.addEventListener('click', (e) => {
                    if (this.mode !== 'drawing' && this.mode !== 'pointing') {
                        e.stopPropagation();
                    }
                });
                
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts when typing in input fields
                    const isTyping = e.target.tagName === 'INPUT' || 
                                   e.target.tagName === 'TEXTAREA' || 
                                   e.target.tagName === 'SELECT';
                    
                    if (e.key === 'Delete' && this.selectedAnnotation && !isTyping) {
                        this.deleteSelectedAnnotation();
                    } else if (e.key === 'r' && (e.ctrlKey || e.metaKey) && !isTyping) {
                        // Refresh stream with Ctrl+R (or Cmd+R on Mac)
                        if (this.stream && !this.elements.refreshStreamBtn.disabled) {
                            e.preventDefault();
                            this.refreshStream();
                        }
                    }
                });
            }
            
            setupAutocomplete() {
                const textarea = this.elements.taskDescription;
                const suggestionsContainer = this.elements.taskDescriptionSuggestions;
                
                // Handle input events
                textarea.addEventListener('input', (e) => {
                    this.handleAutocompleteInput(e);
                });
                
                // Handle keyboard navigation
                textarea.addEventListener('keydown', (e) => {
                    if (this.autocompleteVisible) {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.navigateAutocomplete(1);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.navigateAutocomplete(-1);
                        } else if (e.key === 'Tab' || e.key === 'Enter') {
                            if (this.autocompleteSelectedIndex >= 0) {
                                e.preventDefault();
                                this.selectAutocompleteSuggestion();
                            }
                        } else if (e.key === 'Escape') {
                            this.hideAutocomplete();
                        }
                    }
                });
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!textarea.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                        this.hideAutocomplete();
                    }
                });
                
                // Handle textarea blur
                textarea.addEventListener('blur', (e) => {
                    // Delay hiding to allow clicking on suggestions
                    setTimeout(() => {
                        if (!suggestionsContainer.contains(document.activeElement)) {
                            this.hideAutocomplete();
                        }
                    }, 150);
                });
            }
            
            handleAutocompleteInput(e) {
                const value = e.target.value.trim();
                
                if (value.length < 2) {
                    this.hideAutocomplete();
                    return;
                }
                
                // Find matching suggestions based on the entire input
                const suggestions = Array.from(this.taskDescriptions)
                    .filter(desc => desc.toLowerCase().includes(value.toLowerCase()))
                    .sort((a, b) => {
                        // Prioritize exact matches at start
                        const aStartsWith = a.toLowerCase().startsWith(value.toLowerCase());
                        const bStartsWith = b.toLowerCase().startsWith(value.toLowerCase());
                        if (aStartsWith && !bStartsWith) return -1;
                        if (!aStartsWith && bStartsWith) return 1;
                        return a.length - b.length; // Shorter first
                    })
                    .slice(0, 5); // Limit to 5 suggestions
                
                if (suggestions.length > 0) {
                    this.showAutocompleteSuggestions(suggestions, value);
                } else {
                    this.hideAutocomplete();
                }
            }
            
            showAutocompleteSuggestions(suggestions, searchText) {
                const container = this.elements.taskDescriptionSuggestions;
                container.innerHTML = '';
                
                suggestions.forEach((suggestion, index) => {
                    const div = document.createElement('div');
                    div.className = 'autocomplete-suggestion';
                    div.textContent = suggestion;
                    
                    // Highlight matching part - escape special regex characters
                    const escapedSearchText = searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`(${escapedSearchText})`, 'gi');
                    div.innerHTML = suggestion.replace(regex, '<strong>$1</strong>');
                    
                    div.addEventListener('click', () => {
                        this.autocompleteSelectedIndex = index;
                        this.selectAutocompleteSuggestion();
                    });
                    
                    container.appendChild(div);
                });
                
                container.style.display = 'block';
                this.autocompleteVisible = true;
                this.autocompleteSelectedIndex = -1;
            }
            
            navigateAutocomplete(direction) {
                const suggestions = this.elements.taskDescriptionSuggestions.children;
                if (suggestions.length === 0) return;
                
                // Remove previous selection
                if (this.autocompleteSelectedIndex >= 0) {
                    suggestions[this.autocompleteSelectedIndex].classList.remove('selected');
                }
                
                // Update selection
                this.autocompleteSelectedIndex += direction;
                
                if (this.autocompleteSelectedIndex < 0) {
                    this.autocompleteSelectedIndex = suggestions.length - 1;
                } else if (this.autocompleteSelectedIndex >= suggestions.length) {
                    this.autocompleteSelectedIndex = 0;
                }
                
                // Add new selection
                suggestions[this.autocompleteSelectedIndex].classList.add('selected');
                
                // Scroll into view
                suggestions[this.autocompleteSelectedIndex].scrollIntoView({
                    block: 'nearest'
                });
            }
            
            selectAutocompleteSuggestion() {
                const suggestions = this.elements.taskDescriptionSuggestions.children;
                if (this.autocompleteSelectedIndex < 0 || this.autocompleteSelectedIndex >= suggestions.length) {
                    return;
                }
                
                const selectedText = suggestions[this.autocompleteSelectedIndex].textContent;
                const textarea = this.elements.taskDescription;
                
                // Replace the entire textarea content with the selected suggestion
                textarea.value = selectedText;
                textarea.setSelectionRange(selectedText.length, selectedText.length);
                textarea.focus();
                
                this.hideAutocomplete();
            }
            
            setAnnotationInteractivity(enabled) {
                // Enable/disable pointer events on existing annotations
                const annotations = this.elements.screenshotContainer.querySelectorAll('.bbox-overlay, .annotation-marker');
                annotations.forEach(annotation => {
                    annotation.style.pointerEvents = enabled ? 'auto' : 'none';
                });
            }
            
            hideAutocomplete() {
                this.elements.taskDescriptionSuggestions.style.display = 'none';
                this.autocompleteVisible = false;
                this.autocompleteSelectedIndex = -1;
            }
            
            async checkServerConnection() {
                try {
                    const response = await fetch(`${this.serverUrl}/list-files`);
                    if (response.ok) {
                        this.updateStatus('Server connected - files will save to data/ folder');
                    }
                } catch (error) {
                    this.updateStatus('Server not running - start with: npm start', 'error');
                    this.showFileStatus('Server not detected. Run "npm start" in terminal', 'error');
                }
            }
            
            async loadExistingDataset() {
                try {
                    const response = await fetch(`${this.serverUrl}/load-dataset`);
                    if (response.ok) {
                        const data = await response.json();
                        this.dataset = data;
                        
                        // Update IDs to continue from existing data
                        if (this.dataset.images.length > 0) {
                            this.nextFrameId = Math.max(...this.dataset.images.map(img => img.id)) + 1;
                        }
                        if (this.dataset.annotations.length > 0) {
                            this.nextAnnotationId = Math.max(...this.dataset.annotations.map(ann => ann.id)) + 1;
                        }
                        
                        // Populate autocomplete with existing task descriptions
                        this.dataset.annotations.forEach(ann => {
                            if (ann.attributes && ann.attributes.task_description) {
                                this.taskDescriptions.add(ann.attributes.task_description.trim());
                            }
                        });
                        
                        this.updateDatasetStats();
                        this.updateStatus(`Loaded existing dataset: ${this.dataset.images.length} images`);
                        this.showFileStatus(`Successfully loaded ${this.dataset.images.length} images and ${this.dataset.annotations.length} annotations`, 'success');
                    } else if (response.status === 404) {
                        // No existing dataset found
                        this.updateStatus('No existing dataset found - starting fresh');
                        this.showFileStatus('No dataset file found at data/annotations_coco.json', 'error');
                    } else {
                        // Other error
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to load dataset');
                    }
                } catch (error) {
                    // Network or other errors
                    console.error('Error loading dataset:', error);
                    this.updateStatus('Error loading dataset', 'error');
                    this.showFileStatus(`Failed to load dataset: ${error.message}`, 'error');
                }
            }
            
            startSequence() {
                if (this.currentSequence) {
                    alert('A sequence is already in progress. End it first.');
                    return;
                }
                
                // Use a temporary ID that will be replaced with first frame's filename
                const tempSequenceId = `temp_seq_${Date.now()}`;
                this.currentSequence = {
                    id: tempSequenceId,
                    tempId: true, // Flag to indicate this needs to be replaced
                    startTime: new Date().toISOString(),
                    endTime: null,
                    frames: [],
                    totalActions: 0,
                    description: '',
                    firstFrameFilename: null // Will store the first frame's filename
                };
                
                this.sequenceHistory = [];
                this.sequences[tempSequenceId] = this.currentSequence;
                
                // Update UI
                this.elements.startSequenceBtn.disabled = true;
                this.elements.endSequenceBtn.disabled = false;
                this.elements.sequenceIndicator.style.display = 'inline-block';
                this.elements.sequenceId.textContent = 'Pending...'; // Show pending until first frame
                this.elements.sequenceFrameCount.textContent = '0';
                this.elements.sequenceSection.style.display = 'block';
                this.elements.currentSequenceId.textContent = 'Will be set from first frame';
                this.elements.currentSequenceFrames.textContent = '0';
                this.elements.sequenceStartTime.textContent = new Date(this.currentSequence.startTime).toLocaleString();
                
                this.updateStatus('Started sequence - ID will be set from first frame');
                this.updateSequenceHistory();
            }
            
            endSequence() {
                if (!this.currentSequence) return;
                
                const description = prompt('Enter a description for this sequence:');
                if (description === null) return; // User cancelled
                
                this.currentSequence.endTime = new Date().toISOString();
                this.currentSequence.description = description;
                
                // No need to add to dataset.sequences since we're storing at frame level
                // Just save the dataset with updated frame information
                this.saveDatasetToServer();
                
                // Reset UI
                this.elements.startSequenceBtn.disabled = false;
                this.elements.endSequenceBtn.disabled = true;
                this.elements.sequenceIndicator.style.display = 'none';
                this.elements.sequenceSection.style.display = 'none';
                this.elements.frameSequenceMetadata.style.display = 'none';
                
                this.updateStatus(`Ended sequence ${this.currentSequence.id} with ${this.currentSequence.frames.length} frames`);
                this.showFileStatus(`Sequence ${this.currentSequence.id} completed with ${this.currentSequence.frames.length} frames`, 'success');
                
                this.currentSequence = null;
                this.sequenceHistory = [];
            }
            
            updateSequenceHistory() {
                const historyContainer = this.elements.sequenceHistory;
                
                if (this.sequenceHistory.length === 0) {
                    historyContainer.innerHTML = '<div style="padding: 10px; color: #666; text-align: center;">No actions in sequence yet</div>';
                    return;
                }
                
                historyContainer.innerHTML = '';
                this.sequenceHistory.forEach((item, index) => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    
                    const time = new Date(item.timestamp).toLocaleTimeString();
                    
                    historyItem.innerHTML = `
                        <div class="history-item-number">${index + 1}</div>
                        <div class="history-item-action">
                            <strong>${item.action}</strong>
                            <div class="history-item-time">${time}</div>
                        </div>
                    `;
                    
                    historyContainer.appendChild(historyItem);
                });
                
                // Scroll to bottom
                historyContainer.scrollTop = historyContainer.scrollHeight;
            }
            
            async startStream() {
                try {
                    this.stream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            cursor: 'always'
                        },
                        audio: false
                    });
                    
                    this.elements.videoStream.srcObject = this.stream;
                    this.elements.videoContainer.style.display = 'block';
                    this.elements.placeholder.style.display = 'none';
                    this.elements.screenshotContainer.style.display = 'none';
                    
                    // Enable/disable buttons
                    this.elements.startStreamBtn.disabled = true;
                    this.elements.captureFrameBtn.disabled = false;
                    this.elements.refreshStreamBtn.disabled = false;
                    this.elements.stopStreamBtn.disabled = false;
                    
                    this.mode = 'streaming';
                    this.updateStatus('Live streaming - interact with your window and capture when ready');
                    this.updateModeIndicator('Streaming', 'streaming');
                    
                    // Handle stream end
                    this.stream.getVideoTracks()[0].addEventListener('ended', () => {
                        this.stopStream();
                    });
                    
                } catch (error) {
                    this.updateStatus('Error: ' + error.message, 'error');
                }
            }
            
            async refreshStream() {
                if (!this.stream) return;
                
                // Don't refresh if we're in the middle of annotating
                if (this.currentFrame && this.elements.screenshotContainer.style.display !== 'none') {
                    if (!confirm('You have unsaved annotations. Refresh stream anyway?')) {
                        return;
                    }
                }
                
                try {
                    // Temporarily disable refresh button to prevent multiple clicks
                    this.elements.refreshStreamBtn.disabled = true;
                    this.updateStatus('Refreshing stream...');
                    
                    // Get current video track
                    const videoTrack = this.stream.getVideoTracks()[0];
                    if (videoTrack) {
                        // Apply constraints to refresh the capture
                        await videoTrack.applyConstraints({
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            frameRate: { ideal: 30 }
                        });
                    }
                    
                    // Force video element to reload
                    this.elements.videoStream.srcObject = null;
                    await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
                    this.elements.videoStream.srcObject = this.stream;
                    
                    // Return to streaming view if we were annotating
                    if (this.currentFrame) {
                        this.elements.videoContainer.style.display = 'block';
                        this.elements.screenshotContainer.style.display = 'none';
                        this.elements.drawBboxBtn.disabled = true;
                        this.elements.addPointBtn.disabled = true;
                        this.elements.annotationForm.style.display = 'none';
                        
                        // Reset button states
                        this.elements.drawBboxBtn.classList.remove('active');
                        this.elements.addPointBtn.classList.remove('active');
                        
                        // Clear current frame
                        this.currentFrame = null;
                        this.selectedAnnotation = null;
                        this.mode = 'streaming';
                        this.updateModeIndicator('Streaming', 'streaming');
                    }
                    
                    this.updateStatus('Stream refreshed successfully');
                    
                } catch (error) {
                    console.error('Error refreshing stream:', error);
                    this.updateStatus('Error refreshing stream: ' + error.message, 'error');
                } finally {
                    // Re-enable refresh button
                    this.elements.refreshStreamBtn.disabled = false;
                }
            }
            
            captureFrame() {
                if (!this.stream) return;
                
                const video = this.elements.videoStream;
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                
                // Get the last complete annotation from sequence history
                let previousAnnotation = null;
                if (this.sequenceHistory.length > 0) {
                    const lastHistory = this.sequenceHistory[this.sequenceHistory.length - 1];
                    previousAnnotation = lastHistory.annotation || null;
                }
                
                this.currentFrame = {
                    id: this.nextFrameId++,
                    dataUrl: canvas.toDataURL('image/png'),
                    width: canvas.width,
                    height: canvas.height,
                    timestamp: new Date().toISOString(),
                    annotations: [],
                    // Add sequence metadata
                    sequenceId: this.currentSequence ? this.currentSequence.id : null,
                    sequencePosition: this.currentSequence ? this.currentSequence.frames.length + 1 : null,
                    previousAnnotation: previousAnnotation // Store complete annotation object
                };
                
                // Display the captured frame
                this.elements.screenshot.src = this.currentFrame.dataUrl;
                this.elements.videoContainer.style.display = 'none';
                this.elements.screenshotContainer.style.display = 'block';
                
                // Enable annotation buttons
                this.elements.drawBboxBtn.disabled = false;
                this.elements.addPointBtn.disabled = false;
                
                // Update UI
                this.elements.frameId.value = `frame_${this.currentFrame.id}`;
                this.updateStatus(`Frame ${this.currentFrame.id} captured - add annotations`);
                this.updateModeIndicator('Annotating');
                
                // Update sequence metadata display
                if (this.currentSequence) {
                    this.elements.frameSequenceMetadata.style.display = 'block';
                    this.elements.sequencePosition.value = `${this.currentFrame.sequencePosition} of ${this.currentSequence.frames.length + 1}`;
                    if (previousAnnotation) {
                        const actionDesc = previousAnnotation.attributes.task_description || 
                                         `${previousAnnotation.attributes.action_type} on ${previousAnnotation.attributes.element_info || 'UI element'}`;
                        this.elements.previousAction.value = actionDesc;
                    } else {
                        this.elements.previousAction.value = 'None';
                    }
                } else {
                    this.elements.frameSequenceMetadata.style.display = 'none';
                }
                
                // Clear previous annotations from display
                this.clearAnnotationDisplay();
                this.updateAnnotationList();
                
                // Hide annotation form
                this.elements.annotationForm.style.display = 'none';
                this.selectedAnnotation = null;
            }
            
            toggleDrawMode() {
                if (this.mode === 'drawing') {
                    this.mode = 'annotating';
                    this.elements.drawBboxBtn.classList.remove('active');
                    this.updateModeIndicator('Annotating');
                    this.setAnnotationInteractivity(true);
                } else {
                    this.mode = 'drawing';
                    this.elements.drawBboxBtn.classList.add('active');
                    this.elements.addPointBtn.classList.remove('active');
                    this.updateModeIndicator('Drawing Box', 'drawing');
                    this.updateStatus('Click and drag to draw bounding box');
                    this.setAnnotationInteractivity(false);
                }
            }
            
            togglePointMode() {
                if (this.mode === 'pointing') {
                    this.mode = 'annotating';
                    this.elements.addPointBtn.classList.remove('active');
                    this.updateModeIndicator('Annotating');
                    this.setAnnotationInteractivity(true);
                } else {
                    this.mode = 'pointing';
                    this.elements.addPointBtn.classList.add('active');
                    this.elements.drawBboxBtn.classList.remove('active');
                    this.updateModeIndicator('Adding Points', 'drawing');
                    this.updateStatus('Click to add interaction points');
                    this.setAnnotationInteractivity(false);
                }
            }
            
            handleMouseDown(e) {
                if (!this.currentFrame) return;
                
                const rect = this.elements.screenshot.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.mode === 'drawing') {
                    e.preventDefault();
                    this.startDrawing(x, y);
                } else if (this.mode === 'pointing') {
                    e.preventDefault();
                    this.addClickPoint(x, y);
                }
            }
            
            handleMouseMove(e) {
                if (!this.drawingBbox || this.mode !== 'drawing') return;
                
                const rect = this.elements.screenshot.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.updateDrawing(x, y);
            }
            
            handleMouseUp(e) {
                if (!this.drawingBbox || this.mode !== 'drawing') return;
                
                const rect = this.elements.screenshot.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.finishDrawing(x, y);
            }
            
            startDrawing(x, y) {
                this.drawingBbox = true;
                this.currentBbox = {
                    startX: x,
                    startY: y,
                    element: document.createElement('div')
                };
                
                this.currentBbox.element.className = 'bbox-overlay';
                this.currentBbox.element.style.left = x + 'px';
                this.currentBbox.element.style.top = y + 'px';
                this.currentBbox.element.style.width = '0px';
                this.currentBbox.element.style.height = '0px';
                this.currentBbox.element.style.pointerEvents = 'none';
                this.currentBbox.element.style.zIndex = '1001'; // Ensure it's above other annotations
                
                this.elements.screenshotContainer.appendChild(this.currentBbox.element);
            }
            
            updateDrawing(x, y) {
                if (!this.currentBbox) return;
                
                const width = x - this.currentBbox.startX;
                const height = y - this.currentBbox.startY;
                
                if (width < 0) {
                    this.currentBbox.element.style.left = x + 'px';
                    this.currentBbox.element.style.width = Math.abs(width) + 'px';
                } else {
                    this.currentBbox.element.style.width = width + 'px';
                }
                
                if (height < 0) {
                    this.currentBbox.element.style.top = y + 'px';
                    this.currentBbox.element.style.height = Math.abs(height) + 'px';
                } else {
                    this.currentBbox.element.style.height = height + 'px';
                }
            }
            
            finishDrawing(x, y) {
                this.drawingBbox = false;
                
                if (!this.currentBbox) return;
                
                const imgWidth = this.elements.screenshot.offsetWidth;
                const imgHeight = this.elements.screenshot.offsetHeight;
                const scaleX = this.currentFrame.width / imgWidth;
                const scaleY = this.currentFrame.height / imgHeight;
                
                // Calculate final bbox
                const x1 = Math.min(this.currentBbox.startX, x);
                const y1 = Math.min(this.currentBbox.startY, y);
                const x2 = Math.max(this.currentBbox.startX, x);
                const y2 = Math.max(this.currentBbox.startY, y);
                
                // Minimum size check
                if (Math.abs(x2 - x1) < 5 || Math.abs(y2 - y1) < 5) {
                    this.currentBbox.element.remove();
                    this.currentBbox = null;
                    return;
                }
                
                // Convert to absolute coordinates
                const bbox = [
                    x1 * scaleX,
                    y1 * scaleY,
                    (x2 - x1) * scaleX,
                    (y2 - y1) * scaleY
                ];
                
                // Remove the temporary overlay
                this.currentBbox.element.remove();
                
                // Create annotation
                const annotation = {
                    id: this.nextAnnotationId++,
                    bbox: bbox,
                    category_id: 1, // default to click
                    area: bbox[2] * bbox[3],
                    iscrowd: 0,
                    attributes: {
                        task_description: '',
                        action_type: 'click',
                        element_info: '',
                        custom_metadata: {}
                    }
                };
                
                this.currentFrame.annotations.push(annotation);
                this.displayAnnotation(annotation);
                this.updateAnnotationList();
                this.selectAnnotation(annotation);
                
                this.currentBbox = null;
                this.updateStatus('Bounding box added - fill in annotation details');
            }
            
            addClickPoint(x, y) {
                const imgWidth = this.elements.screenshot.offsetWidth;
                const imgHeight = this.elements.screenshot.offsetHeight;
                const scaleX = this.currentFrame.width / imgWidth;
                const scaleY = this.currentFrame.height / imgHeight;
                
                // Convert to absolute coordinates
                const absX = x * scaleX;
                const absY = y * scaleY;
                
                // Create annotation with just keypoints (no bbox)
                const annotation = {
                    id: this.nextAnnotationId++,
                    keypoints: [absX, absY, 2],
                    category_id: 1,
                    area: 0,
                    iscrowd: 0,
                    attributes: {
                        task_description: '',
                        action_type: 'click',
                        element_info: '',
                        custom_metadata: {}
                    }
                };
                
                this.currentFrame.annotations.push(annotation);
                this.displayAnnotation(annotation);
                this.updateAnnotationList();
                this.selectAnnotation(annotation);
                
                this.updateStatus('Click point added - fill in annotation details');
            }
            
            displayAnnotation(annotation) {
                const imgWidth = this.elements.screenshot.offsetWidth;
                const imgHeight = this.elements.screenshot.offsetHeight;
                const scaleX = imgWidth / this.currentFrame.width;
                const scaleY = imgHeight / this.currentFrame.height;
                
                if (annotation.keypoints) {
                    // Display as point
                    const marker = document.createElement('div');
                    marker.className = 'annotation-marker';
                    marker.textContent = annotation.id;
                    marker.style.left = (annotation.keypoints[0] * scaleX) + 'px';
                    marker.style.top = (annotation.keypoints[1] * scaleY) + 'px';
                    marker.dataset.annotationId = annotation.id;
                    
                    // Make marker clickable - use annotation ID to find current annotation
                    marker.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const currentAnnotation = this.currentFrame.annotations.find(a => a.id === annotation.id);
                        if (currentAnnotation) {
                            this.selectAnnotation(currentAnnotation);
                        }
                    });
                    
                    this.elements.screenshotContainer.appendChild(marker);
                } else {
                    // Display as bbox
                    const bbox = document.createElement('div');
                    bbox.className = 'bbox-overlay';
                    bbox.style.left = (annotation.bbox[0] * scaleX) + 'px';
                    bbox.style.top = (annotation.bbox[1] * scaleY) + 'px';
                    bbox.style.width = (annotation.bbox[2] * scaleX) + 'px';
                    bbox.style.height = (annotation.bbox[3] * scaleY) + 'px';
                    bbox.dataset.annotationId = annotation.id;
                    
                    // Add label
                    const label = document.createElement('div');
                    label.className = 'bbox-label';
                    label.textContent = annotation.id;
                    bbox.appendChild(label);
                    
                    // Make entire bbox clickable - use annotation ID to find current annotation
                    bbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const currentAnnotation = this.currentFrame.annotations.find(a => a.id === annotation.id);
                        if (currentAnnotation) {
                            this.selectAnnotation(currentAnnotation);
                        }
                    });
                    
                    this.elements.screenshotContainer.appendChild(bbox);
                }
            }
            
            clearAnnotationDisplay() {
                const elements = this.elements.screenshotContainer.querySelectorAll('.bbox-overlay, .annotation-marker');
                elements.forEach(el => el.remove());
            }
            
            updateAnnotationList() {
                this.elements.annotationList.innerHTML = '';
                
                if (!this.currentFrame || this.currentFrame.annotations.length === 0) {
                    this.elements.annotationList.innerHTML = '<div style="padding: 10px; color: #666; text-align: center;">No annotations yet</div>';
                    return;
                }
                
                this.currentFrame.annotations.forEach(annotation => {
                    const item = document.createElement('div');
                    item.className = 'annotation-item';
                    if (this.selectedAnnotation && this.selectedAnnotation.id === annotation.id) {
                        item.classList.add('selected');
                    }
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-annotation';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.title = 'Delete annotation';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteAnnotation(annotation);
                    };
                    
                    const typeSpan = document.createElement('span');
                    typeSpan.className = `annotation-type-badge ${annotation.keypoints ? 'point' : 'bbox'}`;
                    typeSpan.textContent = annotation.keypoints ? 'Point' : 'Box';
                    
                    const taskDesc = annotation.attributes.task_description || 'No task description';
                    const shortDesc = taskDesc.length > 30 ? taskDesc.substring(0, 30) + '...' : taskDesc;
                    
                    item.innerHTML = `
                        <strong>Annotation ${annotation.id}</strong>
                        <div style="font-size: 12px; color: #666; margin-top: 2px;">${annotation.attributes.action_type} - ${shortDesc}</div>
                    `;
                    
                    item.querySelector('strong').appendChild(typeSpan);
                    item.appendChild(deleteBtn);
                    item.addEventListener('click', () => this.selectAnnotation(annotation));
                    this.elements.annotationList.appendChild(item);
                });
            }
            
            selectAnnotation(annotation) {
                this.selectedAnnotation = annotation;
                this.elements.annotationForm.style.display = 'block';
                
                // Highlight selected annotation
                document.querySelectorAll('.bbox-overlay, .annotation-marker').forEach(el => {
                    el.classList.toggle('selected', el.dataset.annotationId == annotation.id);
                });
                
                // Update annotation info
                const isPoint = !!annotation.keypoints;
                this.elements.annotationInfo.innerHTML = `
                    <strong>Annotation ID:</strong> ${annotation.id}<br>
                    <strong>Type:</strong> ${isPoint ? 'Click Point' : 'Bounding Box'}<br>
                    ${isPoint ? 
                        `<strong>Position:</strong> (${Math.round(annotation.keypoints[0])}, ${Math.round(annotation.keypoints[1])})` :
                        `<strong>Size:</strong> ${Math.round(annotation.bbox[2])} × ${Math.round(annotation.bbox[3])} px`
                    }
                `;
                
                // Load annotation data
                this.elements.taskDescription.value = annotation.attributes.task_description || '';
                this.elements.actionType.value = annotation.attributes.action_type;
                this.elements.elementInfo.value = annotation.attributes.element_info || '';
                
                // Load custom metadata
                this.loadCustomMetadata(annotation.attributes.custom_metadata || {});
                
                this.updateAnnotationList();
            }
            
            loadCustomMetadata(metadata) {
                // Clear existing metadata fields (except add button)
                const container = this.elements.customMetadata;
                const metadataItems = container.querySelectorAll('.metadata-item');
                metadataItems.forEach(item => item.remove());
                
                // Add metadata fields
                Object.entries(metadata).forEach(([key, value]) => {
                    this.createMetadataField(key, value);
                });
            }
            
            addMetadataField() {
                this.createMetadataField('', '');
            }
            
            createMetadataField(key = '', value = '') {
                const container = this.elements.customMetadata;
                const addButton = this.elements.addMetadataBtn;
                
                const metadataItem = document.createElement('div');
                metadataItem.className = 'metadata-item';
                
                metadataItem.innerHTML = `
                    <input type="text" class="form-control metadata-key" placeholder="Field name" value="${key}">
                    <input type="text" class="form-control metadata-value" placeholder="Field value" value="${value}">
                    <button type="button" class="button danger">×</button>
                `;
                
                // Add delete functionality
                const deleteBtn = metadataItem.querySelector('.button');
                deleteBtn.addEventListener('click', () => metadataItem.remove());
                
                // Insert before the add button
                container.insertBefore(metadataItem, addButton);
            }
            
            saveAnnotation() {
                if (!this.selectedAnnotation) return;
                
                // Find the current annotation in the frame's annotations array
                const annotationIndex = this.currentFrame.annotations.findIndex(a => a.id === this.selectedAnnotation.id);
                if (annotationIndex === -1) {
                    this.updateStatus('Error: Annotation not found', 'error');
                    return;
                }
                
                // Update the annotation in the array
                const annotation = this.currentFrame.annotations[annotationIndex];
                const taskDesc = this.elements.taskDescription.value.trim();
                annotation.attributes.task_description = taskDesc;
                annotation.attributes.action_type = this.elements.actionType.value;
                annotation.attributes.element_info = this.elements.elementInfo.value;
                
                // Add to autocomplete if not empty
                if (taskDesc) {
                    this.taskDescriptions.add(taskDesc);
                }
                
                // Collect custom metadata
                const customMetadata = {};
                const metadataItems = this.elements.customMetadata.querySelectorAll('.metadata-item');
                metadataItems.forEach(item => {
                    const key = item.querySelector('.metadata-key').value.trim();
                    const value = item.querySelector('.metadata-value').value.trim();
                    if (key && value) {
                        customMetadata[key] = value;
                    }
                });
                annotation.attributes.custom_metadata = customMetadata;
                
                // Update category based on action type
                const categoryMap = {
                    'click': 1,
                    'type': 2,
                    'select': 3,
                    'hover': 4,
                    'drag': 5,
                    'right_click': 6,
                    'double_click': 7
                };
                annotation.category_id = categoryMap[annotation.attributes.action_type] || 1;
                
                // Update the selected annotation reference
                this.selectedAnnotation = annotation;
                
                // Update the annotation list to show the changes
                this.updateAnnotationList();
                
                // Flash the save button to indicate success
                const saveBtn = this.elements.saveAnnotationBtn;
                const originalText = saveBtn.textContent;
                const originalClass = saveBtn.className;
                saveBtn.textContent = 'Saved!';
                saveBtn.className = 'button success';
                
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.className = originalClass;
                }, 1000);
                
                this.updateStatus(`Annotation ${annotation.id} saved successfully`);
            }
            
            deleteAnnotation(annotation) {
                if (confirm(`Delete annotation ${annotation.id}?`)) {
                    // Remove from array
                    const index = this.currentFrame.annotations.findIndex(a => a.id === annotation.id);
                    if (index > -1) {
                        this.currentFrame.annotations.splice(index, 1);
                    }
                    
                    // Remove from display
                    const element = this.elements.screenshotContainer.querySelector(`[data-annotation-id="${annotation.id}"]`);
                    if (element) {
                        element.remove();
                    }
                    
                    // Clear selection if this was selected
                    if (this.selectedAnnotation && this.selectedAnnotation.id === annotation.id) {
                        this.selectedAnnotation = null;
                        this.elements.annotationForm.style.display = 'none';
                    }
                    
                    this.updateAnnotationList();
                    this.updateStatus(`Annotation ${annotation.id} deleted`);
                }
            }
            
            deleteSelectedAnnotation() {
                if (this.selectedAnnotation) {
                    this.deleteAnnotation(this.selectedAnnotation);
                }
            }
            
            async saveCurrentFrame() {
                if (!this.currentFrame) {
                    alert('No frame captured');
                    return;
                }
                
                try {
                    const timestamp = new Date(this.currentFrame.timestamp).toISOString()
                        .replace(/:/g, '-')  // Replace colons with hyphens for valid filenames
                        .replace(/\..+Z$/, '') // Remove milliseconds and Z
                        .replace('T', '_');
                    const imageFilename = `${timestamp}.png`;
                    
                    // If this is the first frame in a sequence, update the sequence ID
                    if (this.currentSequence && this.currentSequence.tempId && this.currentSequence.frames.length === 0) {
                        const oldId = this.currentSequence.id;
                        const newId = imageFilename.replace('.png', ''); // Use filename without extension as sequence ID
                        
                        // Update sequence object
                        this.currentSequence.id = newId;
                        this.currentSequence.tempId = false;
                        this.currentSequence.firstFrameFilename = imageFilename;
                        
                        // Update sequences map
                        delete this.sequences[oldId];
                        this.sequences[newId] = this.currentSequence;
                        
                        // Update current frame's sequence ID
                        this.currentFrame.sequenceId = newId;
                        
                        // Update UI
                        this.elements.sequenceId.textContent = newId;
                        this.elements.currentSequenceId.textContent = newId;
                    }
                    
                    const imageResponse = await fetch(`${this.serverUrl}/save-image`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: imageFilename,
                            data: this.currentFrame.dataUrl
                        })
                    });
                    
                    if (!imageResponse.ok) throw new Error('Failed to save image');
                    
                    // Create COCO image entry with image metadata
                    const imageEntry = {
                        id: this.currentFrame.id,
                        file_name: imageFilename,
                        width: this.currentFrame.width,
                        height: this.currentFrame.height,
                        date_captured: this.currentFrame.timestamp,
                        application: this.elements.application.value || '',
                        platform: this.elements.platform.value || '',
                        // Add sequence metadata to image
                        sequence_id: this.currentFrame.sequenceId,
                        sequence_position: this.currentFrame.sequencePosition,
                        previous_annotation: this.currentFrame.previousAnnotation // Store complete annotation object
                    };
                    
                    // Add to dataset
                    this.dataset.images.push(imageEntry);
                    
                    // Add annotations with proper image_id
                    this.currentFrame.annotations.forEach(ann => {
                        // Don't spread the entire annotation object, construct it properly
                        const cocoAnnotation = {
                            id: ann.id,
                            image_id: this.currentFrame.id,  // This should reference the image, not the annotation
                            category_id: ann.category_id,
                            bbox: ann.bbox,
                            area: ann.area,
                            iscrowd: ann.iscrowd,
                            attributes: ann.attributes
                        };
                        
                        // Only add keypoints if they exist
                        if (ann.keypoints) {
                            cocoAnnotation.keypoints = ann.keypoints;
                        }
                        
                        this.dataset.annotations.push(cocoAnnotation);
                    });
                    
                    // Update sequence if active
                    if (this.currentSequence && this.currentFrame.sequenceId) {
                        this.currentSequence.frames.push(this.currentFrame.id);
                        this.currentSequence.totalActions += this.currentFrame.annotations.length;
                        
                        // Add actions to history
                        this.currentFrame.annotations.forEach(ann => {
                            const actionDesc = ann.attributes.task_description || 
                                             `${ann.attributes.action_type} on ${ann.attributes.element_info || 'UI element'}`;
                            this.sequenceHistory.push({
                                frameId: this.currentFrame.id,
                                action: actionDesc,
                                actionType: ann.attributes.action_type,
                                annotation: ann, // Store the full annotation object
                                timestamp: new Date().toISOString()
                            });
                        });
                        
                        // Update UI
                        this.elements.sequenceFrameCount.textContent = this.currentSequence.frames.length;
                        this.elements.currentSequenceFrames.textContent = this.currentSequence.frames.length;
                        this.updateSequenceHistory();
                    }
                    
                    // Save updated dataset
                    await this.saveDatasetToServer();
                    
                    // Save frame to local array
                    this.frames.push(this.currentFrame);
                    
                    // Update stats
                    this.updateDatasetStats();
                    
                    // Return to video stream
                    this.elements.videoContainer.style.display = 'block';
                    this.elements.screenshotContainer.style.display = 'none';
                    this.elements.drawBboxBtn.disabled = true;
                    this.elements.addPointBtn.disabled = true;
                    this.elements.annotationForm.style.display = 'none';
                    
                    // Reset button states
                    this.elements.drawBboxBtn.classList.remove('active');
                    this.elements.addPointBtn.classList.remove('active');
                    
                    this.showFileStatus(`Frame ${this.currentFrame.id} saved to data/${imageFilename}`, 'success');
                    this.updateStatus(`Frame ${this.currentFrame.id} saved with ${this.currentFrame.annotations.length} annotations`);
                    this.updateModeIndicator('Streaming', 'streaming');
                    
                    // Reset current frame but keep image metadata
                    const savedApp = this.elements.application.value;
                    const savedPlatform = this.elements.platform.value;
                    
                    this.currentFrame = null;
                    this.selectedAnnotation = null;
                    this.mode = 'streaming';
                    
                    // Keep the metadata for next frame
                    this.elements.application.value = savedApp;
                    this.elements.platform.value = savedPlatform;
                    
                } catch (error) {
                    this.showFileStatus(`Error saving: ${error.message}`, 'error');
                    this.updateStatus('Error saving frame', 'error');
                }
            }
            
            async saveDatasetToServer() {
                const response = await fetch(`${this.serverUrl}/save-json`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: 'annotations_coco.json',
                        data: this.dataset
                    })
                });
                
                if (!response.ok) throw new Error('Failed to save dataset');
                return response.json();
            }
            
            async exportDataset() {
                try {
                    await this.saveDatasetToServer();
                    this.showFileStatus('Dataset exported to data/annotations_coco.json', 'success');
                    this.updateStatus(`Dataset exported: ${this.dataset.images.length} images, ${this.dataset.annotations.length} annotations`);
                } catch (error) {
                    this.showFileStatus(`Export error: ${error.message}`, 'error');
                }
            }
            
            stopStream() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                this.elements.videoContainer.style.display = 'none';
                this.elements.screenshotContainer.style.display = 'none';
                this.elements.placeholder.style.display = 'block';
                this.elements.startStreamBtn.disabled = false;
                this.elements.captureFrameBtn.disabled = true;
                this.elements.refreshStreamBtn.disabled = true;
                this.elements.stopStreamBtn.disabled = true;
                this.elements.drawBboxBtn.disabled = true;
                this.elements.addPointBtn.disabled = true;
                this.elements.annotationForm.style.display = 'none';
                
                // Reset button states
                this.elements.drawBboxBtn.classList.remove('active');
                this.elements.addPointBtn.classList.remove('active');
                
                // Don't clear sequence data when stopping stream
                // User might want to continue the sequence later
                
                this.mode = 'idle';
                this.selectedAnnotation = null;
                this.currentFrame = null;
                this.updateStatus('Stream stopped');
                this.updateModeIndicator('Idle');
            }
            
            updateDatasetStats() {
                this.elements.imageCount.textContent = this.dataset.images.length;
                this.elements.annotationCount.textContent = this.dataset.annotations.length;
            }
            
            updateStatus(message, type = 'info') {
                this.elements.statusText.textContent = message;
                this.elements.statusText.style.color = type === 'error' ? '#dc3545' : '#666';
            }
            
            updateModeIndicator(mode, className = '') {
                this.elements.modeIndicator.textContent = mode;
                this.elements.modeIndicator.className = 'mode-indicator';
                if (className) {
                    this.elements.modeIndicator.classList.add(className);
                }
            }
            
            showFileStatus(message, type = 'success') {
                this.elements.fileStatus.textContent = message;
                this.elements.fileStatus.className = `file-status ${type}`;
                this.elements.fileStatus.style.display = 'block';
                
                setTimeout(() => {
                    this.elements.fileStatus.style.display = 'none';
                }, 5000);
            }
        }
        
        // Initialize
        const collector = new GUICollectorWithServer();
    </script>
</body>
</html>